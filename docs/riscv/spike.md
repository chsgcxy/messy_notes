# 从spike分析一款模拟器的设计与实现

## 前言

目前在做RISCV模拟器的开发，其中功能模拟器基于spike进行修改。在看spike代码的时候，发现有些部分的实现比我想象的要复杂，应该是我少考虑了很多情况。那么由此我产生了一个疑问，要做一款功能型的SOC模拟器，到底要考虑那些方面？或者说，让我从零到一去做一款功能型模拟器，应该怎么去做？

凭自我的感觉，从需求和设计出发，大致想到如下几点：

- 如何组织SOC各个模块的运行，最简单直接的应该就是处理器按照时钟运行，其他绝大多数单元都被动的接受处理器的访问即可。
- 如何组织指令集及译码，即找到一个比较简单的从指令码到指令实现的管理方式，并且指令集管理应该具有比较好的扩展性。
- 如何组织寄存器
- 如何管理地址，是否需要MMU及总线的抽象，如何使处理器发出的虚拟地址能够正确高效的访问到目的设备
- 应该有一定的调试功能，能够显示指令流，甚至单步调试，查看一些寄存器状态
- 怎样实现printf打印，这会对目标代码的调试非常有帮助
- 怎样让模拟器停下来

上面这些是假如我去做一款模拟器我会想到的，那么spike是怎样实现的呢？它的设计者是否也考虑过我的这些问题，他们又是如何处理的呢？下面就针对spike中的部分实现细节进行分析，并探讨上述问题。这就是这篇文章的目的。

## spike实现

spike版本为1.0.1-dev

### 目录结构

首先从目录结构来看spike大致实现了哪些东西

- disasm 从名称上来看是反汇编，实际内容是根据指令码组装反汇编字符串，应该是为了debug和显示指令流
- fdt 扁平设备树，猜测设备树是它用来实现SOC配置的方式，我很赞同这种方式，感觉比gem5的python方式要更好
- fesvr 这个命名不太好理解，是源于Frontend Server的缩写。它包含一些与riscv无关的构成模拟器的组件，SOC组件的一些基础抽象，以及模拟器的运行管理。它实现了一个模拟器的大框架。这样来看，它的命名似乎还挺合理。
- riscv 其中的insns目录中是riscv指令集的实现，剩下的是SOC的具体实现
- softfloat 浮点库，来自于IEEE Floating-Point Arithmetic Packag
- spike-main 模拟器程序入口

从目录结构上来看，结构比较简单，没有太多的分层，可以看出spike的目的并不是做一个功能性模拟器框架，而是完全针对riscv进行的设计。riscv目录是实现的核心，fesvr是模拟器基础，除此之外fdt可以作为一个单独的模块进行分析。它既然有fdt,那么它必然有模块化的设计，这些设计应该都是在riscv中实现的。

### sim核心
