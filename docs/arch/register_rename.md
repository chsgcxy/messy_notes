# 乱序CPU的寄存器重命名(Register Renaming)机制

在乱序CPU中，寄存器重命名是非常重要的一个机制，它在CPU乱序执行时，主要有两个作用

- 消除指令之间的反向依赖问题（读后写依赖（WAR）和写后写依赖（WAW））
- 当指令执行发生异常或分支预测错误而取消后面的指令时可以保证现场还原的准确

实现思路就是执行指令时不直接操作架构寄存器，而是先操作一个与架构寄存器有映射关系的中间寄存器，当这条指令提交的时候再写到架构寄存器中。
当然，这个思路的描述不一定准确，因为随着乱序CPU的发展，Register Renaming的实现方式也在发展。
不同的CPU，其内部的Register Renaming实现可能会存在差异，有的物理寄存器和指令集寄存器是独立的，有的是合并成一个寄存器堆。还有一些分类中
分为显式重命名机制和隐式重命名机制。这些需要我们具体的CPU架构具体分析。

总结一下，就是在不增加指令集寄存器的前提下（可以理解为软件无感），用更多的寄存器来解决乱序执行时的寄存器反向依赖问题。

## 工作原理

### 物理寄存器与ISA寄存器

要区分物理寄存器和逻辑寄存器，逻辑寄存器又可以称为ISA寄存器。ISA寄存器是对程序员可见的，
但物理寄存器是不可见的，它是逻辑寄存器的一种具体实现。

### 反向依赖

#### WAR反向依赖

假如我们有如下代码

```asm
lw x2, 0(x1);
add x3, x2, x4;
sub x2, x4, x5;
```

如果乱序CPU没有寄存器重命名机制，那么当lw发生cache未命中时，add指令会因为x2寄存器被锁住而无法执行，此时，sub指令因为x4和x5已经准备好，所以可以执行，但sub指令一旦执行完成之后，就会改写x2寄存器，后续再执行add指令时，就会因为乱序执行导致结果x3错误。如下图所示，这就是所谓的WAR反相关。

#### WAW反向依赖

```asm
lw x3, 0(x1);
add x2, x3, x4;
mul x2, x6, x4;
```

如果乱序CPU没有寄存器重命名机制，那么当lw发生cache未命中时，add指令会因为x3寄存器被锁住而无法执行，此时，mul指令因为x6和x4已经准备好，所以可以执行，但mul指令和add指令执行完成后都会改写x2寄存器，如果mul先执行完成，add后执行完成，那么x2寄存器就不再时mul的结果，而是add的结果。程序就会因此出错。这就是所谓的WAW反向依赖。

### 重命名过程

这里按照一个常用的处理机制来分析，处理逻辑如下：

1. 将每条指令的源ISA寄存器映射为该ISA寄存器最近映射到的那个物理寄存器
2. 将每条指令的目的ISA寄存器映射到新的物理寄存器

而且要保证第一步要先执行，不然如果遇到源寄存器和目的寄存器是同一个的情况时，就会发生错误。

执行如下指令流，我们可以看到经过寄存器重命名，add指令和sub指令已经不存在依赖关系，
消除了WAR反向依赖。

```text


x2 ----> R2
x3 ----> R3
x4 ----> R4
x5 ----> R5
x6 ----> R6
                   |x1|x2|x3|x4|x5|x6|
             ------------------------------
    重命名前        |R1|R2|R3|R4|R5|R6|    重命名后
1. lw x2, 0(x1)    |  |R7|  |  |  |  |  lw  R7, 0(R1)
    数据相关        |  |  |  |  |  |  |    数据相关
2. add x3, x2, x4  |  |  |R8|  |  |  |  add R8, R7, R4
     反向依赖       |  |  |  |  |  |  |     不相关
3. sub x2, x4, x5  |  |R9|  |  |  |  |  sub R9, R4, R5
     数据相关       |  |  |  |  |  |  |     数据相关
4. mul x6, x2, x4  |  |  |  |  |  |R10|  mul R10, R9, R4
```

因此sub指令可以在lw和add等待资源的情况下先执行完成。
问题在于物理寄存器的释放时机，通常来说，每完成一条指令，
就可以释放该指令目的ISA寄存器上一次映射的物理寄存器。
在上面的例子中，在mul指令rename的时候，R7可用吗？

## gem5 O3 CPU的重命名机制

参考gem5章节
